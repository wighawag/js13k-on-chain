{
  "language": "Solidity",
  "sources": {
    "src/JS24K.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract JS24K {\n\tusing Strings for uint96;\n\tusing Strings for uint256;\n\tusing Strings for uint160;\n\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n\tmapping(uint256 => address) public ownerOf;\n\n\tevent Debug(bytes data, bytes gameData);\n\n\t// function debug(bytes calldata gameData) external {\n\t// \tbytes memory deployCode = bytes.concat(hex\"61FFFF600E60003961FFFF6000F3\", gameData);\n\t// \tbytes1 lenByte1 = bytes1(uint8(gameData.length >> 8));\n\t// \tbytes1 lenByte2 = bytes1(uint8(gameData.length & 0xFF));\n\t// \tdeployCode[1] = lenByte1;\n\t// \tdeployCode[9] = lenByte1;\n\t// \tdeployCode[2] = lenByte2;\n\t// \tdeployCode[10] = lenByte2;\n\n\t// \temit Debug(deployCode, gameData);\n\t// }\n\n\tfunction debug(bytes calldata) external {\n\t\tuint256 newContract;\n\n\t\tassembly {\n\t\t\tlet len := calldataload(36)\n\t\t\tlet p := mload(0x40)\n\t\t\tmstore(p, 0x61FFFF600E60003961FFFF6000F3000000000000000000000000000000000000)\n\t\t\tlet lenByte1 := shr(8, len)\n\t\t\tlet lenByte2 := and(len, 0xFF)\n\t\t\tmstore8(add(p, 1), lenByte1)\n\t\t\tmstore8(add(p, 2), lenByte2)\n\t\t\tmstore8(add(p, 9), lenByte1)\n\t\t\tmstore8(add(p, 10), lenByte2)\n\t\t\tcalldatacopy(add(p, 14), 68, len)\n\n\t\t\tnewContract := create(0, p, add(len, 14))\n\t\t\tlog2(p, add(len, 14), len, newContract)\n\t\t\tlog4(0, 0, 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, 0, caller(), newContract)\n\t\t}\n\t}\n\n\tfunction deployGame() internal returns (uint256) {\n\t\tuint256 newContract;\n\t\tassembly (\"memory-safe\") {\n\t\t\tlet len := calldataload(36)\n\t\t\tlet p := mload(0x40)\n\t\t\tmstore(p, 0x61FFFF600E60003961FFFF6000F3000000000000000000000000000000000000)\n\t\t\tlet lenByte1 := shr(8, len)\n\t\t\tlet lenByte2 := and(len, 0xFF)\n\t\t\tmstore8(add(p, 1), lenByte1)\n\t\t\tmstore8(add(p, 2), lenByte2)\n\t\t\tmstore8(add(p, 9), lenByte1)\n\t\t\tmstore8(add(p, 10), lenByte2)\n\t\t\tcalldatacopy(add(p, 14), 68, len)\n\n\t\t\tnewContract := create(0, p, add(len, 14))\n\t\t}\n\t\treturn newContract;\n\t}\n\n\t// function mint(bytes calldata gameData) external {\n\t// \tbytes memory deployCode = bytes.concat(hex\"61FFFF600E60003961FFFF6000F3\", gameData);\n\t// \tbytes1 lenByte1 = bytes1(uint8(gameData.length >> 8));\n\t// \tbytes1 lenByte2 = bytes1(uint8(gameData.length & 0xFF));\n\t// \tdeployCode[1] = lenByte1;\n\t// \tdeployCode[9] = lenByte1;\n\t// \tdeployCode[2] = lenByte2;\n\t// \tdeployCode[10] = lenByte2;\n\n\t// \tuint256 newContract;\n\t// \tassembly {\n\t// \t\tnewContract := create(0, add(deployCode, 32), mload(deployCode))\n\t// \t}\n\t// \townerOf[newContract] = msg.sender;\n\t// \temit Transfer(address(0), msg.sender, newContract);\n\t// }\n\n\tfunction mint(bytes calldata) external {\n\t\tuint256 newContract;\n\t\tassembly (\"memory-safe\") {\n\t\t\tlet len := calldataload(36)\n\t\t\tlet p := mload(0x40)\n\t\t\tmstore(p, 0x61FFFF600E60003961FFFF6000F3000000000000000000000000000000000000)\n\t\t\tlet lenByte1 := shr(8, len)\n\t\t\tlet lenByte2 := and(len, 0xFF)\n\t\t\tmstore8(add(p, 1), lenByte1)\n\t\t\tmstore8(add(p, 2), lenByte2)\n\t\t\tmstore8(add(p, 9), lenByte1)\n\t\t\tmstore8(add(p, 10), lenByte2)\n\t\t\tcalldatacopy(add(p, 14), 68, len)\n\n\t\t\tnewContract := create(0, p, add(len, 14))\n\t\t\tlog2(p, add(len, 14), len, newContract) // need this line, no idea why, looks like some memory management issues\n\t\t}\n\t\townerOf[newContract] = msg.sender;\n\t\temit Transfer(address(0), msg.sender, newContract);\n\t}\n\n\tfunction mintRaw(bytes memory deployCode) external {\n\t\tuint256 newContract;\n\t\tassembly {\n\t\t\tnewContract := create(0, add(deployCode, 32), mload(deployCode))\n\t\t}\n\t\townerOf[newContract] = msg.sender;\n\t\temit Transfer(address(0), msg.sender, newContract);\n\t}\n\n\tfunction contractURI(address receiver, uint96 per10Thousands) external pure returns (string memory) {\n\t\treturn\n\t\t\tstring(\n\t\t\t\tbytes.concat(\n\t\t\t\t\t'data:application/json,{\"name\":\"JS24K\",\"description\":JS24K%20on-chain%20.\",\"image\":\"data:image/svg+xml;base64,\",\"external_link\":\"https://JS24Kgames.com\",\"seller_fee_basis_points\":',\n\t\t\t\t\tbytes(per10Thousands.toString()),\n\t\t\t\t\t',\"fee_recipient\":\"',\n\t\t\t\t\tbytes(uint160(receiver).toHexString(20)),\n\t\t\t\t\t'\"}'\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\tfunction at(address _addr) public view returns (bytes memory o_code) {\n\t\tassembly {\n\t\t\t// retrieve the size of the code, this needs assembly\n\t\t\tlet size := extcodesize(_addr)\n\t\t\t// allocate output byte array - this could also be done without assembly\n\t\t\t// by using o_code = new bytes(size)\n\t\t\to_code := mload(0x40)\n\t\t\t// new \"memory end\" including padding\n\t\t\tmstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n\t\t\t// store length in memory\n\t\t\tmstore(o_code, size)\n\t\t\t// actually retrieve the code, this needs assembly\n\t\t\textcodecopy(_addr, add(o_code, 0x20), 0, size)\n\t\t}\n\t}\n\n\tfunction tokenURI(uint256 id) external view returns (string memory) {\n\t\tbytes memory gameData = at(address(uint160(id)));\n\n\t\tstring memory gameName = \"Triska\";\n\t\tstring memory gameId = \"triska\";\n\t\treturn\n\t\t\tstring(\n\t\t\t\tbytes.concat(\n\t\t\t\t\t'data:application/json,{\"name\":\"',\n\t\t\t\t\tbytes(gameName),\n\t\t\t\t\t'\",\"description\":\"A%20Game\",\"external_url\":\"',\n\t\t\t\t\t\"https://JS24Kgames.com/entries/\",\n\t\t\t\t\tbytes(gameId),\n\t\t\t\t\t'\",\"image\":\"',\n\t\t\t\t\t\"<svg%2520viewBox='0%25200%252032%252016'xmlns='http://www.w3.org/2000/svg'><text%2520x='50%'y='50%'dominant-baseline='middle'text-anchor='middle'style='fill:rgb(219,39,119);font-size:12px;'>\",\n\t\t\t\t\tbytes(gameName),\n\t\t\t\t\t\"</text></svg>\"\n\t\t\t\t\t'\",',\n\t\t\t\t\t'\"animation_url\":\"data:text/html;base64,',\n\t\t\t\t\tgameData,\n\t\t\t\t\t'\"}'\n\t\t\t\t)\n\t\t\t);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}